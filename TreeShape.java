/* TreeShape class by Timothy Goodwin
 * tlg2132
 * COMSW3134
 * 
 * This class draws the Huffman tree using the set of keys and values generated by the HuffmanTree
 * class.
 * 
 */import java.awt.*;
import java.awt.Color;
import java.awt.geom.*;
import java.util.*;
import java.util.Set;


public class TreeShape {
	
	private int x;
	private int y;
	private int width; //based on #leaf nodes in tree
	private int height; 
	private int mid;
	private int yLoc;
	private int xPrev;
	private HashMap<Character, String> map;
	
	public TreeShape(int x, int y, int width, int height, HashMap<Character, String> a){
		this.x = x; //start x coord
		this.y = y; //start y coord
		this.width = width; // width of window based on #leaf nodes
		this.height = height; //height based on #nodes
		this.map = a;
		mid = (x + width)/2; //middle of window
		xPrev = mid;
		yLoc = y + 50;
		//System.out.println("size: " + map.size());
	}

	public Dimension getSize() {
		return new Dimension(width, height);
	}
	
	public void draw(Graphics2D g2){

		Point2D.Double parent; //start root at top middle
		Point2D.Double right;
		Point2D.Double left;
		Line2D.Double e;
		Line2D.Double f;
		Ellipse2D.Double node;
		String pathCode;
		boolean offset = false;
		char[] code; //works
		
		Set<Character> keySet = map.keySet();
		Iterator<Character> keyIterator = keySet.iterator();
		Collection<String> codeSet = map.values();
		Iterator<String> codeIterator = codeSet.iterator();
		
		for (int i = 0; i < codeSet.size(); i++){ //Go through set of CODES
			pathCode = codeIterator.next();
			char key = keyIterator.next();
			code = pathCode.toCharArray();
			//NEW CODE, MUST RESET MIN
			int prev = mid;
			int dx = mid;
			int xnew = mid;
			String keyString;
			
			for (int j=0; j < code.length; j++){
				
				parent = new Point2D.Double(prev, yLoc);
				node = new Ellipse2D.Double(prev - 3, yLoc - 2, 6, 6); //DRAW PARENT NODE
				g2.draw(node);
				g2.fill(node);
				yLoc = yLoc + 40;
				int temp = dx / 2;
				dx = temp;
				
				if (code[j] == '1'){ //GO RIGHT
					offset = true;
					xnew = prev + dx;
			
					right = new Point2D.Double(xnew, yLoc); //ERROR HERE ERROR HERE ERROR HERE
					//System.out.println(xLoc+": " + yLoc);
					e = new Line2D.Double(parent, right);
					g2.draw(e);
				}
				
				if (code[j] == '0'){ //GO LEFT
					offset = false;
					xnew = prev - dx;
			
					left = new Point2D.Double(xnew, yLoc); //draws point (other scenario) with updated x,y
					f = new Line2D.Double(parent, left);
				
					g2.draw(f);
					
				}
				if (j == code.length -1){ //WE ARE AT THE END OF HTE CODE
					node = new Ellipse2D.Double(xnew - 10, yLoc - 1, 20, 20); //DRAW PARENT NODE
					g2.draw(node);
					
					if (key == ' ')
						keyString = "sp";
					else if (key == '\t')
						keyString = "ht";
					else if (key == '\n')
						keyString = "nl";
					else
						keyString = Character.toString(key);
					g2.drawString(keyString, xnew - 5, yLoc +14);
					if (offset == true)
						g2.drawString(pathCode, xnew - 10, yLoc + 40);
					else
						g2.drawString(pathCode, xnew - 10, yLoc + 30);
					
				}
				prev = xnew;
			}
			yLoc = y + 50;
		}
	}

}
